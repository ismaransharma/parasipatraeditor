<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Parasi Patra Editor</title>
    <link rel="manifest" href="manifest.json" />
    <meta name="theme-color" content="#0066b3" />
    <style>
      body {
        font-family: Arial, sans-serif;
        background: #f4f4f4;
        display: flex;
        flex-direction: column;
        align-items: center;
        padding: 20px;
      }

      h1 {
        margin-bottom: 20px;
        color: #333;
      }

      #controls {
        margin-bottom: 20px;
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }

      input[type="file"],
      input[type="color"],
      input[type="number"],
      input[type="text"],
      button,
      input[type="range"] {
        padding: 8px;
        border-radius: 5px;
        border: 1px solid #ccc;
        font-size: 14px;
      }

      #canvasContainer {
        border: 2px solid #ccc;
        background: #fff;
      }

      canvas {
        display: block;
        max-width: 100%;
        height: auto;
      }
    </style>
  </head>

  <body>
    <h1>Parasi Patra Editor</h1>

    <div id="controls">
      <input type="file" id="imageUpload" accept="image/*" />
      <input
        type="text"
        id="watermarkText"
        placeholder="Watermark Text"
        value="www.parasipatra.com"
        readonly
      />
      <input type="number" id="fontSize" min="10" max="100" value="22" />
      <input type="range" id="opacity" min="0" max="1" step="0.01" value="1" />
      <input type="range" id="rotation" min="0" max="360" step="1" value="0" />
      <button id="downloadBtn">Download</button>
    </div>

    <div id="canvasContainer">
      <canvas id="canvas"></canvas>
    </div>

    <script>
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");

      let img = new Image();
      let watermark = document.getElementById("watermarkText").value;
      let textX = 50,
        textY = 50;
      let isDragging = false;
      let fontSize = 22;
      let opacity = 1;
      let rotation = 0;
      const lineColor = "#0066b3";

      // Upload image
      document.getElementById("imageUpload").addEventListener("change", (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = function (event) {
          img.onload = () => {
            canvas.width = img.width;
            canvas.height = img.height;
            textX = canvas.width / 2;
            textY = canvas.height / 2;
            draw();
          };
          img.src = event.target.result;
        };
        reader.readAsDataURL(file);
      });

      // Update watermark text
      document
        .getElementById("watermarkText")
        .addEventListener("input", (e) => {
          watermark = e.target.value;
          draw();
        });

      // Update font size
      document.getElementById("fontSize").addEventListener("input", (e) => {
        fontSize = e.target.value;
        draw();
      });

      // Update opacity
      document.getElementById("opacity").addEventListener("input", (e) => {
        opacity = e.target.value;
        draw();
      });

      // Update rotation
      document.getElementById("rotation").addEventListener("input", (e) => {
        rotation = e.target.value;
        draw();
      });

      // Draw function
      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        if (img.src) ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

        ctx.save();
        ctx.translate(textX, textY);
        ctx.rotate((rotation * Math.PI) / 180);
        ctx.font = `${fontSize}px Arial`;
        ctx.globalAlpha = opacity;

        // Dynamic line length
        const totalLineWidth = canvas.width * 0.5;
        const textWidth = ctx.measureText(watermark).width;
        const lineWidth = (totalLineWidth - textWidth) / 2;

        // Draw left line with glow
        ctx.strokeStyle = "#0066b3";
        ctx.lineWidth = 1.5;
        ctx.shadowColor = "#ffffff";
        ctx.shadowBlur = 8;
        ctx.beginPath();
        ctx.moveTo(-totalLineWidth / 2, 0);
        ctx.lineTo(-totalLineWidth / 2 + lineWidth, 0);
        ctx.stroke();

        // Draw right line with glow
        ctx.beginPath();
        ctx.moveTo(totalLineWidth / 2 - lineWidth, 0);
        ctx.lineTo(totalLineWidth / 2, 0);
        ctx.stroke();

        // Draw the “WordArt” text: first outline
        ctx.strokeStyle = "#ffffff";
        ctx.lineWidth = 4; // thick outline
        ctx.strokeText(watermark, -textWidth / 2, fontSize / 3);

        // Then fill the text
        ctx.fillStyle = lineColor;
        ctx.fillText(watermark, -textWidth / 2, fontSize / 3);

        ctx.restore();
      }

      // Get mouse position relative to actual canvas pixels
      function getMousePos(canvas, evt) {
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        return {
          x: (evt.clientX - rect.left) * scaleX,
          y: (evt.clientY - rect.top) * scaleY,
        };
      }

      // Drag watermark
      canvas.addEventListener("mousedown", (e) => {
        const pos = getMousePos(canvas, e);
        const mouseX = pos.x;
        const mouseY = pos.y;
        ctx.font = `${fontSize}px Arial`;
        const textHeight = fontSize;
        const totalLineWidth = canvas.width * 0.5;
        if (
          mouseX > textX - totalLineWidth / 2 &&
          mouseX < textX + totalLineWidth / 2 &&
          mouseY > textY - textHeight &&
          mouseY < textY + textHeight
        ) {
          isDragging = true;
        }
      });

      canvas.addEventListener("mousemove", (e) => {
        if (isDragging) {
          const pos = getMousePos(canvas, e);
          textX = pos.x;
          textY = pos.y;
          draw();
        }
      });

      canvas.addEventListener("mouseup", () => {
        isDragging = false;
      });
      canvas.addEventListener("mouseleave", () => {
        isDragging = false;
      });

      // Download image
      document.getElementById("downloadBtn").addEventListener("click", () => {
        const link = document.createElement("a");
        link.download = "watermarked_image.png";
        link.href = canvas.toDataURL();
        link.click();
      });

      // Register service worker for PWA
      if ("serviceWorker" in navigator) {
        window.addEventListener("load", () => {
          navigator.serviceWorker
            .register("./sw.js")
            .then((reg) => console.log("Service Worker registered", reg))
            .catch((err) => console.log("Service Worker failed", err));
        });
      }
    </script>
  </body>
</html>
